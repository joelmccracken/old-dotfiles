#+PROPERTY: header-args :mkdirp yes
#+STARTUP: showall
#+TITLE: Joel's Personal Configuration Management Setup
* Introduction
  This is my personal automation setup.

  The structure of this whole thing very largely based off of
  the [[http://gettingstartedwithchef.com/first-steps-with-chef.html][getting started with chef]] tutorial.

  The overall steps to recreate my system are:
  1. Acquire this code.
  2. Install chef with the omnibus installer.
  3. Run Chef.
  4. Restore private data (???).
* Things that need to be done
**** TODO add a "chef-env" script that runs other scripts in the chef reset environment
     e.g. something like
     set all the env vars
     set path
     exec "$@"
     etc
     note: in bash bypass rvm gem function with 'command' builtin
**** TODO a good backup plan
     e.g. tarsnap/s3 backups, scripted
**** TODO omnifocus
**** TODO git
**** TODO ruby
**** TODO evernote
**** TODO dropbox
**** TODO virtualbox
**** TODO vagrant
**** TODO extract shadow_directory to its own cookbook
**** TODO extract firefox_profile to its own cookbook
**** TODO create a build.sh for tangling dotfiles.org
**** TODO document any other manual things, if there are any
* Other External Services I Use
  I think this needs to be mentioned
  - read later
  - pinboard.in
  - feedly
* Data
  Backups sent to s3 for now (bucket: jnm-private)
* README.md

The README is a starting point, so some basics are provided.

#+BEGIN_SRC markdown :tangle ./README.md
  # Dotfiles

  Configuration management system for my (Joel McCracken) personal
  computing setup.


  You should see the org mode literate source for this repository at: [dotfiles.org](./dotfiles.org)
#+END_SRC
* Interface executables
  The scripts you actually will want to run.

  Highlights:

  - ~./bin/install-chef-standalone.sh~ installs chef via omnibus
    installer.
  - ~./bin/run-chef.sh~ runs chef and converges the system.
  - ~./bin/get-cookbooks.sh~ gets cookbooks managed by librarian-chef.

** Resetting environment because of RVM
  I still use RVM. Thus, I have to occasionally deal with irritating
  environmental issues. This bit of code sets things up for chef:
#+NAME: reset-environment
#+BEGIN_SRC sh
  # necessary for the chef-version of ruby not to
  # be confused about locations of files,
  # at least on my system. YMMV
  unset GEM_HOME
  unset GEM_PATH

  # make sure to put the omnibus-installed version of chef at
  # the front of the path
  PATH="/opt/chef/bin:/opt/chef/embedded/bin:$PATH"
#+END_SRC
** Install Chef with Omnibus installer
/This script is exported to ~bin/install-chef-standalone.sh~./
#+BEGIN_SRC sh :tangle ./bin/install-chef-standalone.sh :shebang "#!/bin/bash"
  curl -LO https://www.opscode.com/chef/install.sh
  sudo bash install.sh
  rm -rf install.sh
#+END_SRC
** Fetch Cookbooks
#+BEGIN_SRC sh :tangle ./bin/get-cookbooks.sh :shebang "#!/bin/bash" :noweb yes
  # include reset environment code
  <<reset-environment>>

  # absolute paths to executables
  # are used to avoid problems with RVM.
  sudo /opt/chef/embedded/bin/gem install librarian-chef
  /opt/chef/embedded/bin/librarian-chef install --verbose
#+END_SRC
** Converge the system
#+BEGIN_SRC sh :tangle ./bin/run-chef.sh :shebang "#!/bin/bash" :noweb yes
  # include reset environment code
  <<reset-environment>>

  # absolute paths to executables
  # are used to avoid problems with RVM.
  sudo /opt/chef/bin/chef-solo -c solo.rb -j solo.json "$@"
#+END_SRC
** Running Tests
#+BEGIN_SRC sh :tangle ./bin/run-tests.sh :shebang "#!/bin/bash" :noweb yes
  /opt/chef/embedded/bin/ruby test/var_directories_test.rb
#+END_SRC
* Cookbooks
  The meat of this project rests in the cookbooks.
  The rest is just bookkeeping.
** Personal
This is where the main action of system configuration happens.
This is going to be getting larger, so I
imagine I will need to modularize things a bit eventually.

This piece should:
- create any directories that are missing
- create any symlinks to e.g. dotfiles
- create an "inbox" shadow directory
*** The "Inbox" Shadow directory
#+NAME: inbox
#+BEGIN_SRC ruby
  shadow_directory "Downloads -> Inbox" do
    replace File.expand_path("~/Downloads")
    with    File.expand_path("~/Inbox")
    owner   node[:username]
    group   "staff"
  end

#+END_SRC

*** var directories

have a var, and a secrets dir so far.
#+NAME: var-directories
#+BEGIN_SRC ruby
  directory File.join(home_dir, "var") do
    owner node['username']
    group node['username']
    mode "0755"
    recursive true
    action :create
  end

  directory File.join(home_dir, "var", "secrets") do
    owner node['username']
    group node['username']
    mode "0700"
    recursive true
    action :create
  end
#+END_SRC
*** dotfiles/symlinks
for now i am just replacing the old `bin/link` script

#+name: dotfiles-symlinks
#+BEGIN_SRC ruby
  link "bin" do
    target_file File.join(home_dir, "bin")
    to File.join dotfiles_dir, "bin"
    action :create
    owner "joel"
    group "staff"
  end

  link "lib" do
    target_file File.join(home_dir, "lib")
    to File.join dotfiles_dir, "lib"
    action :create
    owner "joel"
    group "staff"
  end

  Dir[File.join dotfiles_dir, "profile/*"].each do |file|
    link file do
      target_file File.join(home_dir, file)
      to File.join dotfiles_dir, "profile", file
      action :create
      owner "joel"
      group "staff"
    end
  end

#+END_SRC
*** Firefox Profile
This is a piece of work I am fairly proud of. It took me a long time
to figure out how to manually create and add extensions to a firefox
profile.
**** Complete Profile
#+NAME: firefox-profile
#+BEGIN_SRC ruby :noweb yes
  expand_file = ->(name){
    ::File.expand_path ::File.join(__FILE__, "../../files/default", name)
  }

  hashed_pw = ::File.read(::File.expand_path "~/var/secrets/fx-last-pass-pw-hash").strip
  lastpass_encoded_pw = %Q{user_pref("extensions.lastpass.loginpws", "mccracken.joel%40gmail.com=#{hashed_pw}");}

  personal_firefox_profile "Personal" do
    owner node[:username]
    group "staff"

    location File.expand_path("~/var/FirefoxProfiles/Personal")

    extensions ["mozrepl-1.1.2-fx.xpi",
                "firebug-addon-1843-latest.xpi",
                "lastpass-addon-8542-latest.xpi",
                "pinboard.xpi",
                "pocket.xpi"
               ].map &expand_file

    prefs ['user_pref("extensions.mozrepl.autoStart", true);',

           #lastpass
           'user_pref("extensions.lastpass.ffhasloggedinsuccessfully", true);',
           'user_pref("extensions.lastpass.rememberPassword", true);',
           'user_pref("extensions.lastpass.rememberUsername", true);',
           lastpass_encoded_pw,
           '"user_pref("extensions.lastpass.loginusers", "mccracken.joel%40gmail.com")',
          ]

  end
#+END_SRC
**** Resource and Provider
Setting up a Firefox profile required quite a bit of hacking. I want
to extract these when I get a chance

The file ~site-cookbooks/personal/resources/firefox_profile.rb~:
#+BEGIN_SRC ruby :tangle ./site-cookbooks/personal/resources/firefox_profile.rb
  actions :install
  default_action :install

  attribute :profile_name,       :kind_of => String, :name_attribute => true
  attribute :extensions, :kind_of => Array, :default => []
  attribute :location,   :kind_of => String
  attribute :owner,      :kind_of => String
  attribute :group,      :kind_of => String
  attribute :prefs,      :kind_of => Array, :default => []

  def location_exists?
    ::File.exists? ::File.expand_path(::File.join(location, "/prefs.js"))
  end

  def extension_exists? extension
    ::File.exists? ::File.expand_path(::File.join(location, "/extensions/", extension))
  end


#+END_SRC
The file ~site-cookbooks/personal/providers/firefox_profile.rb~:
#+BEGIN_SRC ruby :tangle ./site-cookbooks/personal/providers/firefox_profile.rb
  require 'mixlib/shellout'
  require 'fileutils'
  require 'chef/util/file_edit'
  require 'rexml/document'

  include Chef::Mixin::ShellOut

  action :install do

    # manually adding extensions to a firefox profile is a very tricky
    # thing to get right. The order that these steps take place are that
    # way for a reason and probably shouldn't be messed with that much.
    # However, I fear that this will break at some point, anyway.

    unless new_resource.location_exists?
      cmd = <<-FX_CMD.strip
        #{node[:firefox_bin]} -CreateProfile "#{new_resource.profile_name} #{new_resource.location}"
      FX_CMD
      converge_by "create a new profile with: #{cmd}" do
        shell_out!(cmd, user: new_resource.owner)
      end
    end

    unless new_resource.extensions.empty?
      converge_by "add extension auto-enable permissions to profile's prefs.js" do
        insert_auto_enable_extensions_setting
      end

      new_resource.extensions.each do |extension|
        install_extension extension
      end
    end

    run_firefox_if_needed

    unless new_resource.prefs.empty?
      file_edit = Chef::Util::FileEdit.new prefsjs_file
      new_resource.prefs.each do |pref|
        converge_by "ensure prefs.js contains '#{pref}'" do
          file_edit_ensure_line file_edit, pref
        end
      end
      file_edit.write_file
    end

    if new_resource.owner
      ownership = [new_resource.owner, new_resource.group].compact.join ":"

      converge_by "set profile ownership to #{ownership}" do
        cmd = <<-FX_CMD.strip
          cd #{new_resource.location}
          chown -R #{ownership} *
        FX_CMD

        shell_out!(cmd, user: new_resource.owner)
      end
    end
  end

  def prefsjs_file
    "#{new_resource.location}/prefs.js"
  end


  def firefox_needs_run!
    @firefox_needs_run = true
  end


  # Firefox does some fancy work that seems important here.
  # I don't know precisely what it is, but doing this in various places
  # tends to eliciit different results.
  def run_firefox_if_needed
    if @firefox_needs_run
      converge_by "briefly run firefox to have it set up the newly-created profile" do
        pipe = IO.popen [node[:firefox_bin], "-P", new_resource.profile_name]
        sleep 5
        Process.kill 9, pipe.pid
      end
    end
  end

  def insert_auto_enable_extensions_setting
    file_edit = Chef::Util::FileEdit.new prefsjs_file

    file_edit_ensure_line file_edit, 'user_pref("extensions.autoDisableScopes", 0);'
    file_edit_ensure_line file_edit, 'user_pref("extensions.enabledScopes", 15);'

    file_edit.write_file
  end


  def file_edit_ensure_line file_edit, string
    file_edit.insert_line_if_no_match Regexp.new(Regexp.escape(string)), string
  end

  def install_extension extension
    installed_name = installed_xpi_name extension
    unless new_resource.extension_exists? installed_name
      converge_by "install extension #{extension}" do
        extension_location = "#{new_resource.location}/extensions/"
        FileUtils.mkdir_p extension_location
        FileUtils.cp extension, ::File.join(extension_location, installed_name)
      end
      firefox_needs_run!
    end
  end

  def installed_xpi_name xpi_file
    @xpi_name_requirements ||= ->{
      chef_gem 'rubyzip'
      require 'zip'
    }.call

    XpiIdFinder.new(xpi_file).find_id
  end

  class XpiIdFinder
    def initialize xpi_file
      @xpi_file = xpi_file
    end

    def find_id
      file = Zip::File.open(@xpi_file)
      install_contents = file.read("install.rdf")

      @doc = REXML::Document.new(install_contents)

      id_node = try_to_find_id_node

      unless id_node
        raise "Could not determine id from XPI: #{@xpi_file}"
      end

      id_node.text + ".xpi"
    end

    private
    def try_to_find_id_node
      REXML::XPath.first(@doc, "/RDF/Description/em:id") ||
        REXML::XPath.first(@doc, "/RDF:RDF/RDF:Description/em:id")
    end
  end


  def whyrun_enabled?
    true
  end

#+END_SRC

*** The Combined Recipe
#+BEGIN_SRC ruby :noweb yes :tangle ./site-cookbooks/personal/recipes/default.rb
  #
  # default recipe
  #

  require 'pry' # i use it all the time
  home_dir = Dir.home(node['username'])
  dotfiles_dir = File.expand_path(File.join(File.expand_path(__FILE__), "../../../../"))

  <<var-directories>>
  <<dotfiles-symlinks>>
  <<inbox>>
  <<firefox-profile>>

#+END_SRC

*** Misc
#+BEGIN_SRC ruby :tangle ./site-cookbooks/personal/attributes/default.rb
default['username'] = 'joel'
#+END_SRC

#+BEGIN_SRC ruby :tangle ./site-cookbooks/personal/metadata.rb
  name             'personal'
  maintainer       'YOUR_COMPANY_NAME'
  maintainer_email 'YOUR_EMAIL'
  license          'All rights reserved'
  description      'Installs/Configures personal'
  long_description IO.read(File.join(File.dirname(__FILE__), 'README.md'))
  version          '0.1.0'


  # externally depends upon shadow directory
  depends "shadow_directory"

#+END_SRC

** Shadow Directory
*** Changelog
    #+BEGIN_SRC markdown :tangle ./site-cookbooks/shadow_directory/CHANGELOG.md
      shadow_directory CHANGELOG
      ==========================

      This file is used to list changes made in each version of the shadow_directory cookbook.

      0.1.0
      -----
      - [Joel McCracken] - Initial release of shadow_directory

    #+END_SRC
*** Readme
    #+BEGIN_SRC markdown :tangle ./site-cookbooks/shadow_directory/README.md
      shadow_directory Cookbook
      =========================

      This cookbook creates a "shadow directory", which
      is a directory is actually linked to another directory.

      This is different than a simple link because it intelligently handles
      any existing files either in the "replace" or "with" directories.

      Requirements
      ------------

      Only tested on OS X, but I doubt there would be any serious issues on
      other platforms.

      Usage
      -----

      `shadow_directory` is intended to be used within another cookbook. Use
      it like so:

      ```
      shadow_directory "Downloads -> Inbox" do
        replace File.expand_path("~/Downloads")
        with    File.expand_path("~/Inbox")
        owner   "johnny"
        group   "cache"
      end
      ```

      Contributing
      ------------

      1. Fork the repository on Github
      2. Create a named feature branch (like `add_component_x`)
      3. Write your change
      4. Write tests for your change (if applicable)
      5. Run the tests, ensuring they all pass
      6. Submit a Pull Request using Github

      License and Authors
      -------------------
      Authors: Joel McCracken

      MIT
    #+END_SRC
*** Metadata
#+BEGIN_SRC ruby :tangle ./site-cookbooks/shadow_directory/metadata.rb
  name             'shadow_directory'
  maintainer       'Joel McCracken'
  maintainer_email 'mccracken.joel@gmail.com'
  license          'MIT'
  description      'Configures shadow_directory on a system'
  long_description IO.read(File.join(File.dirname(__FILE__), 'README.md'))
  version          '0.1.0'

#+END_SRC
*** Provider
#+BEGIN_SRC ruby :tangle ./site-cookbooks/shadow_directory/providers/default.rb
  require 'fileutils'

  MAX_ITERATIONS = 1000
  =begin
  Shadow Directory

  Replaces a directory with a link to another directory. Any contents in
  the directory to be replaced are first moved to the other directory.
  =end

  include Chef::Mixin::ShellOut

  action :install do
    # create the replacement target if it does not exist
    unless current_resource.with_exists?
      converge_by "create new directory #{new_resource.with_path}" do
        ::FileUtils.mkdir_p new_resource.with_path
      end
    end

    # create replacement link if no replace currently exists
    if current_resource.replace_is_link_to_with?
      # nothing; this is the ideal case
      nil
    elsif current_resource.replace_exists?
      handle_existing_replace
    else
      create_symlink
    end


    if new_resource.owner
      ownership = [new_resource.owner, new_resource.group].compact.join ":"
      converge_by "set profile ownership to #{ownership}" do
        cmd = <<-FX_CMD.strip
          chown -R #{ownership} #{new_resource.with_path}
        FX_CMD

        shell_out!(cmd, user: new_resource.owner)
      end
    end
  end

  def handle_existing_replace
    current_resource.files_in_replace.each do |file|
      # does the file already exist at the destination? if so, we need
      # to come up with a unique name for the file

      if ::File.exists?(::File.join(current_resource.with_path, file))
        mv_uniquely file
      else
        converge_by "move #{file} from #{new_resource.replace_path} to #{new_resource.with_path}" do
          ::FileUtils.mv(::File.join(current_resource.replace_path, file),
                         new_resource.with_path)
        end
      end
    end

    converge_by "Remove #{new_resource.replace_path} to make way for link to #{new_resource.with_path}" do
      ::FileUtils.rm_r(current_resource.replace_path, :secure => true)
    end

    create_symlink
  end

  def create_symlink
    converge_by "create link from #{new_resource.replace_path} to #{new_resource.with_path}" do
      ::File.symlink(new_resource.with_path, new_resource.replace_path)
    end
  end

  def mv_uniquely file
    (0..MAX_ITERATIONS).each do |i|
      potential_name = "#{file}.#{i}"
      unless current_resource.file_exists_in_replace?(potential_name)
        converge_by "move #{file} (as #{potential_name}) from #{new_resource.replace_path} to #{new_resource.with_path}" do
          ::FileUtils.mv(::File.join(current_resource.replace_path, file),
                         ::File.join(new_resource.with_path, potential_name))
        end

        return nil
      end
    end
    raise TooManyIterationsCannotMoveFile.new "unable to move file #{file}, all potential file renamings already exist."
  end

  def load_current_resource
    # these would have the same attributes starting out, however we will
    # handle them differently
    @current_resource ||= new_resource.dup
  end

  def whyrun_supported?
    true
  end

  class TooManyIterationsCannotMoveFile < RuntimeError; end

#+END_SRC

*** Resource
#+BEGIN_SRC ruby :tangle ./site-cookbooks/shadow_directory/resources/default.rb
  actions :install
  default_action :install

  attribute :name,    :kind_of => String, :name_attribute => true
  attribute :replace, :kind_of => String, :required => true
  attribute :with,    :kind_of => String, :required => true
  attribute :owner,   :kind_of => String
  attribute :group,   :kind_of => String

  def with_path
    ::File.expand_path(with)
  end

  def replace_path
    ::File.expand_path(replace)
  end

  def replace_exists?
    ::File.exists?(replace_path)
  end

  def with_exists?
    ::File.exists?(with_path)
  end

  def replace_empty?
    # remove both '.' and '..'
    Dir.new(replace_path).entries.reject(&method(:entry_is_meta)).count == 0
  end

  def replace_is_link_to_with?
    ::File.symlink?(replace_path) and
      ::File.readlink(replace_path) == with_path
  end

  def files_in_replace
    ::Dir.entries(::File.join replace_path).reject(&method(:entry_is_meta))
  end

  def file_exists_in_replace?(file)
    ::File.exists? ::File.join(with_path, file)
  end

  private
  def entry_is_meta entry
    entry =~ /^\.\.?$/
  end

#+END_SRC
* Librarian-Chef
** Knife Configuration
#+BEGIN_SRC ruby :tangle ./.chef/knife.rb
  site_cookbooks = File.expand_path(File.join File.dirname(__FILE__), "../", "site-cookbooks")
  cookbook_path [ site_cookbooks ]
#+END_SRC
** The Cheffile:
#+BEGIN_SRC ruby :tangle ./Cheffile
  # -*- mode: ruby -*-

  site 'http://community.opscode.com/api/v1'

  cookbook 'sprout-osx-base',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'sprout-osx-base'

  cookbook 'pivotal_workstation',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'pivotal_workstation'

  cookbook 'sprout-osx-apps',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'sprout-osx-apps'

  cookbook 'sprout-osx-settings',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'sprout-osx-settings'

  cookbook 'sprout-pivotal',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'sprout-pivotal'

  cookbook 'osx',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'osx'
#+END_SRC
* Chef Solo Support Files

In order to use Chef solo, we need two files:
- solo.rb, which provides settings for chef. For example, it
  specifies where files should be downloaded to, and where to find
  cookbooks from.

- solo.json, which provides "node attributes", which basically are
  settings for configuring the node. For example, usernames, locations
  of directories to place things, and recipes to run are all things
  that should go in solo.json

~solo.rb~ sets a convenient file cache path and sets the cookbook path
to ~cookbooks~, which is managed by Librarian Chef, and
~site-cookbooks~, which are the local cookbooks:

#+BEGIN_SRC ruby :tangle ./solo.rb
  current_dir = File.expand_path(File.dirname __FILE__)
  file_cache_path ::File.join(current_dir, "tmp", "cache")
  cookbook_path [File.join(current_dir, "cookbooks"),
                 File.join(current_dir, "site-cookbooks")]
#+END_SRC



~solo.json~ specifies the recipes that should be run.
It also specifies where the firefox binary should be found, which is
used in the ~personal~ recipe.

#+BEGIN_SRC js :tangle ./solo.json
  {
    "firefox_bin": "/Applications/Firefox.app/Contents/MacOS/firefox-bin",
    "run_list": [
      "recipe[sprout-osx-apps::emacs]",
      "recipe[sprout-osx-apps::firefox]",
      "recipe[sprout-osx-apps::flux]",
      "recipe[personal]"
    ]
  }
#+END_SRC

* Tests
These should run on a system to test to see that it is the expected
state.

#+BEGIN_SRC ruby :tangle ./test/var_directories_test.rb
  require 'minitest/autorun'
  require 'minitest/pride'

  describe "directories" do
    it "has a ~/var directory" do
      assert dir_exists?("~/var")
    end
    it "has a secrets directory" do
      assert dir_exists?("~/var/secrets")
    end
    it "has a secrets directory" do
      assert dir_exists?("~/var/secrets")
    end
  end

  describe "apps" do
    it "has emacs" do
      assert dir_exists?("/Applications/Emacs.app")
    end

    it "has firefox" do
      assert dir_exists?("/Applications/Firefox.app")
    end
  end

  def dir_exists? dir
    Dir.exists? File.expand_path(dir)
  end
#+END_SRC
* Miscellaneous
** ~.gitignore~
#+BEGIN_SRC fundamental :tangle ./.gitignore
  sprout-wrap/
  cookbooks/

  .rake_test_cache

  ###
  # Ignore Chef key files and secrets
  ###
  .chef/*.pem
  .chef/encrypted_data_bag_secret

  cookbooks
  tmp
  chef-client-running.pid
#+END_SRC
* More Resources
http://gettingstartedwithchef.com/first-steps-with-chef.html
http://docs.opscode.com/install_omnibus.html
http://www.getchef.com/chef/install/
