#+PROPERTY: header-args :mkdirp yes
#+STARTUP: showall
#+TITLE: Joel's Personal Configuration Management Setup
* Introduction
  This is my personal automation setup.

  The structure of this whole thing very largely based off of
  the [[http://gettingstartedwithchef.com/first-steps-with-chef.html][getting started with chef]] tutorial.

  The overall steps to recreate my system are:
  1. Acquire this code.
  2. Install chef with the omnibus installer.
  3. Run Chef.
  4. Restore private data (???).
* Things that need to be done
**** TODO a good backup plan
     e.g. tarsnap/s3 backups, scripted
**** TODO Firefox extension
**** firebug
**** lastpass
**** readitlater
**** pinboard.in bookmark
**** mozrepl
**** TODO omnifocus
**** TODO git
**** TODO ruby
**** TODO flux
**** TODO evernote
**** TODO dropbox
**** TODO virtualbox
**** TODO vagrant
**** TODO extract shadow_directory to its own cookbook
**** TODO extract firefox_profile to its own cookbook
**** TODO create a build.sh for tangling dotfiles.org
**** TODO document any other manual things, if there are any
* Other External Services I Use
  I think this needs to be mentioned
  - read later
  - pinboard.in
  - feedly
* Data
  Backups sent to s3 for now (bucket: jnm-private)
* README.md

The README is a starting point, so some basics are provided.

#+BEGIN_SRC markdown :tangle ./README.md
  # Dotfiles

  Configuration management system for my (Joel McCracken) personal
  computing setup.


  You should see the org mode literate source for this repository at: [dotfiles.org](./dotfiles.org)
#+END_SRC
* Interface executables
  The scripts you actually will want to run.

  Highlights:

  - ~./bin/install-chef-standalone.sh~ installs chef via omnibus
    installer.
  - ~./bin/run-chef.sh~ runs chef and converges the system.
  - ~./bin/get-cookbooks.sh~ gets cookbooks managed by librarian-chef.

** Resetting environment because of RVM
  I still use RVM. Thus, I have to occasionally deal with irritating
  environmental issues. This bit of code sets things up for chef:
#+NAME: reset-environment
#+BEGIN_SRC sh
  # necessary for the chef-version of ruby not to
  # be confused about locations of files,
  # at least on my system. YMMV
  unset GEM_HOME
  unset GEM_PATH

  # make sure to put the omnibus-installed version of chef at
  # the front of the path
  PATH="/opt/chef/bin:/opt/chef/embedded/bin:$PATH"
#+END_SRC
** Install Chef with Omnibus installer
/This script is exported to ~bin/install-chef-standalone.sh~./
#+BEGIN_SRC sh :tangle ./bin/install-chef-standalone.sh :shebang "#!/bin/bash"
  curl -LO https://www.opscode.com/chef/install.sh
  sudo bash install.sh
  rm -rf install.sh
#+END_SRC
** Fetch Cookbooks
#+BEGIN_SRC sh :tangle ./bin/get-cookbooks.sh :shebang "#!/bin/bash" :noweb yes
  # include reset environment code
  <<reset-environment>>

  # absolute paths to executables
  # are used to avoid problems with RVM.
  sudo /opt/chef/embedded/bin/gem install librarian-chef
  /opt/chef/embedded/bin/librarian-chef install --verbose
#+END_SRC
** Converge the system
#+BEGIN_SRC sh :tangle ./bin/run-chef.sh :shebang "#!/bin/bash" :noweb yes
  # include reset environment code
  <<reset-environment>>

  # absolute paths to executables
  # are used to avoid problems with RVM.
  sudo /opt/chef/bin/chef-solo -c solo.rb -j solo.json "$@"
#+END_SRC
** Running Tests
#+BEGIN_SRC sh :tangle ./bin/run-tests.sh :shebang "#!/bin/bash" :noweb yes
  /opt/chef/embedded/bin/ruby test/var_directories_test.rb
#+END_SRC
* Cookbooks
  The meat of this project rests in the cookbooks.
  The rest is just bookkeeping.
** Personal
This is where the main action of system configuration happens.
This is going to be getting larger, so I
imagine I will need to modularize things a bit eventually.
*** The "Inbox" Shadow directory
#+NAME: inbox
#+BEGIN_SRC ruby
  shadow_directory "Downloads -> Inbox" do
    replace File.expand_path("~/Downloads")
    with    File.expand_path("~/Inbox")
  end

#+END_SRC

*** var directories

have a var, and a secrets dir so far.
#+NAME: var-directories
#+BEGIN_SRC ruby
  directory File.join(home_dir, "var") do
    owner node['username']
    group node['username']
    mode "0755"
    recursive true
    action :create
  end

  directory File.join(home_dir, "var", "secrets") do
    owner node['username']
    group node['username']
    mode "0700"
    recursive true
    action :create
  end
#+END_SRC
*** dotfiles/symlinks
for now i am just replacing the old `bin/link` script

#+name: dotfiles-symlinks
#+BEGIN_SRC ruby
  link "bin" do
    target_file File.join(home_dir, "bin")
    to File.join dotfiles_dir, "bin"
    action :create
    owner "joel"
    group "staff"
  end

  link "lib" do
    target_file File.join(home_dir, "lib")
    to File.join dotfiles_dir, "lib"
    action :create
    owner "joel"
    group "staff"
  end

  Dir[File.join dotfiles_dir, "profile/*"].each do |file|
    link file do
      target_file File.join(home_dir, file)
      to File.join dotfiles_dir, "profile", file
      action :create
      owner "joel"
      group "staff"
    end
  end

#+END_SRC
*** The Combined Recipe
#+BEGIN_SRC ruby :noweb yes :tangle ./site-cookbooks/personal/recipes/default.rb
  #
  # default recipe
  #

  home_dir = Dir.home(node['username'])
  dotfiles_dir = File.expand_path(File.join(File.expand_path(__FILE__), "../../../../"))

  <<var-directories>>
  <<dotfiles-symlinks>>
  <<inbox>>
#+END_SRC

*** Misc
#+BEGIN_SRC ruby :tangle ./site-cookbooks/personal/attributes/default.rb
default['username'] = 'joel'
#+END_SRC

#+BEGIN_SRC ruby :tangle ./site-cookbooks/personal/metadata.rb
  name             'personal'
  maintainer       'YOUR_COMPANY_NAME'
  maintainer_email 'YOUR_EMAIL'
  license          'All rights reserved'
  description      'Installs/Configures personal'
  long_description IO.read(File.join(File.dirname(__FILE__), 'README.md'))
  version          '0.1.0'


  # externally depends upon shadow directory
  depends "shadow_directory"

#+END_SRC

** Shadow Directory
*** Changelog
    #+BEGIN_SRC markdown :tangle ./site-cookbooks/shadow_directory/CHANGELOG.md
      shadow_directory CHANGELOG
      ==========================

      This file is used to list changes made in each version of the shadow_directory cookbook.

      0.1.0
      -----
      - [Joel McCracken] - Initial release of shadow_directory

    #+END_SRC
*** Readme
    #+BEGIN_SRC markdown :tangle ./site-cookbooks/shadow_directory/README.md
      shadow_directory Cookbook
      =========================

      This cookbook creates a "shadow directory", which
      is a directory is actually linked to another directory.

      This is different than a simple link because it intelligently handles
      any existing files either in the "replace" or "with" directories.

      Requirements
      ------------

      Only tested on OS X, but I doubt there would be any serious issues on
      other platforms.

      Usage
      -----

      `shadow_directory` is intended to be used within another cookbook. Use
      it like so:

      ```
      shadow_directory "Downloads -> Inbox" do
        replace File.expand_path("~/Downloads")
        with    File.expand_path("~/Inbox")
      end
      ```

      Contributing
      ------------

      1. Fork the repository on Github
      2. Create a named feature branch (like `add_component_x`)
      3. Write your change
      4. Write tests for your change (if applicable)
      5. Run the tests, ensuring they all pass
      6. Submit a Pull Request using Github

      License and Authors
      -------------------
      Authors: Joel McCracken

      MIT
    #+END_SRC
*** Metadata
#+BEGIN_SRC ruby :tangle ./site-cookbooks/shadow_directory/metadata.rb
  name             'shadow_directory'
  maintainer       'Joel McCracken'
  maintainer_email 'mccracken.joel@gmail.com'
  license          'MIT'
  description      'Configures shadow_directory on a system'
  long_description IO.read(File.join(File.dirname(__FILE__), 'README.md'))
  version          '0.1.0'

#+END_SRC
*** Provider
#+BEGIN_SRC ruby :tangle ./site-cookbooks/shadow_directory/providers/default.rb
  require 'fileutils'

  MAX_ITERATIONS = 1000
  =begin
  Shadow Directory

  Replaces a directory with a link to another directory. Any contents in
  the directory to be replaced are first moved to the other directory.
  =end

  action :install do
    # create the replacement target if it does not exist
    unless current_resource.with_exists?
      converge_by "create new directory #{new_resource.with_path}" do
        ::FileUtils.mkdir_p new_resource.with_path
      end
    end


    # create replacement link if no replace currently exists
    if current_resource.replace_is_link_to_with?
      # nothing; this is the ideal case
      nil
    elsif current_resource.replace_exists?
      handle_existing_replace
    else
      create_symlink
    end
  end

  def handle_existing_replace
    current_resource.files_in_replace.each do |file|
      # does the file already exist at the destination? if so, we need
      # to come up with a unique name for the file

      if ::File.exists?(::File.join(current_resource.with_path, file))
        mv_uniquely file
      else
        converge_by "move #{file} from #{new_resource.replace_path} to #{new_resource.with_path}" do
          ::FileUtils.mv(::File.join(current_resource.replace_path, file),
                         new_resource.with_path)
        end
      end
    end

    converge_by "Remove #{new_resource.replace_path} to make way for link to #{new_resource.with_path}" do
      ::FileUtils.rm_r(current_resource.replace_path, :secure => true)
    end

    create_symlink
  end

  def create_symlink
    converge_by "create link from #{new_resource.replace_path} to #{new_resource.with_path}" do
      ::File.symlink(new_resource.with_path, new_resource.replace_path)
    end
  end

  def mv_uniquely file
    (0..MAX_ITERATIONS).each do |i|
      potential_name = "#{file}.#{i}"
      unless current_resource.file_exists_in_replace?(potential_name)
        converge_by "move #{file} (as #{potential_name}) from #{new_resource.replace_path} to #{new_resource.with_path}" do
          ::FileUtils.mv(::File.join(current_resource.replace_path, file),
                         ::File.join(new_resource.with_path, potential_name))
        end

        return nil
      end
    end
    raise TooManyIterationsCannotMoveFile.new "unable to move file #{file}, all potential file renamings already exist."
  end

  def load_current_resource
    # these would have the same attributes starting out, however we will
    # handle them differently
    @current_resource ||= new_resource.dup
  end

  def whyrun_supported?
    true
  end

  class TooManyIterationsCannotMoveFile < RuntimeError; end

#+END_SRC

*** Resource
#+BEGIN_SRC ruby :tangle ./site-cookbooks/shadow_directory/resources/default.rb
  actions :install
  default_action :install

  attribute :name,    :kind_of => String, :name_attribute => true
  attribute :replace, :kind_of => String, :required => true
  attribute :with,    :kind_of => String, :required => true

  def with_path
    ::File.expand_path(with)
  end

  def replace_path
    ::File.expand_path(replace)
  end

  def replace_exists?
    ::File.exists?(replace_path)
  end

  def with_exists?
    ::File.exists?(with_path)
  end

  def replace_empty?
    # remove both '.' and '..'
    Dir.new(replace_path).entries.reject(&method(:entry_is_meta)).count == 0
  end

  def replace_is_link_to_with?
    ::File.symlink?(replace_path) and
      ::File.readlink(replace_path) == with_path
  end

  def files_in_replace
    ::Dir.entries(::File.join replace_path).reject(&method(:entry_is_meta))
  end

  def file_exists_in_replace?(file)
    ::File.exists? ::File.join(with_path, file)
  end

  private
  def entry_is_meta entry
    entry =~ /^\.\.?$/
  end

#+END_SRC
* Librarian-Chef
** Knife Configuration
#+BEGIN_SRC ruby :tangle ./.chef/knife.rb
  site_cookbooks = File.expand_path(File.join File.dirname(__FILE__), "../", "site-cookbooks")
  cookbook_path [ site_cookbooks ]
#+END_SRC
** The Cheffile:
#+BEGIN_SRC ruby :tangle ./Cheffile
  # -*- mode: ruby -*-

  site 'http://community.opscode.com/api/v1'

  cookbook 'sprout-osx-base',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'sprout-osx-base'

  cookbook 'pivotal_workstation',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'pivotal_workstation'

  cookbook 'sprout-osx-apps',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'sprout-osx-apps'

  cookbook 'sprout-osx-settings',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'sprout-osx-settings'

  cookbook 'sprout-pivotal',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'sprout-pivotal'

  cookbook 'osx',
    :git => 'git://github.com/pivotal-sprout/sprout.git',
    :ref => 'mountain-lion',
    :path => 'osx'
#+END_SRC
* Chef Solo Support Files

In order to use Chef solo, we need two files:
- solo.rb, which provides settings for chef. For example, it
  specifies where files should be downloaded to, and where to find
  cookbooks from.

- solo.json, which provides "node attributes", which basically are
  settings for configuring the node. For example, usernames, locations
  of directories to place things, and recipes to run are all things
  that should go in solo.json

~solo.rb~ sets a convenient file cache path and sets the cookbook path
to ~cookbooks~, which is managed by Librarian Chef, and
~site-cookbooks~, which are the local cookbooks:

#+BEGIN_SRC ruby :tangle ./solo.rb
  current_dir = File.expand_path(File.dirname __FILE__)
  file_cache_path ::File.join(current_dir, "tmp", "cache")
  cookbook_path [File.join(current_dir, "cookbooks"),
                 File.join(current_dir, "site-cookbooks")]
#+END_SRC



~solo.json~ specifies the recipes that should be run.
It also specifies where the firefox binary should be found, which is
used in the ~personal~ recipe.

#+BEGIN_SRC js :tangle ./solo.json
  {
    "firefox_bin": "/Applications/Firefox.app/Contents/MacOS/firefox-bin",
    "run_list": [
      "recipe[sprout-osx-apps::emacs]",
      "recipe[sprout-osx-apps::firefox]",
      "recipe[personal]"
    ]
  }
#+END_SRC

* Tests
These should run on a system to test to see that it is the expected
state.

#+BEGIN_SRC ruby :tangle ./test/var_directories_test.rb
  require 'minitest/autorun'
  require 'minitest/pride'

  describe "directories" do
    it "has a ~/var directory" do
      assert dir_exists?("~/var")
    end
    it "has a secrets directory" do
      assert dir_exists?("~/var/secrets")
    end
    it "has a secrets directory" do
      assert dir_exists?("~/var/secrets")
    end
  end

  describe "apps" do
    it "has emacs" do
      assert dir_exists?("/Applications/Emacs.app")
    end

    it "has firefox" do
      assert dir_exists?("/Applications/Firefox.app")
    end
  end

  def dir_exists? dir
    Dir.exists? File.expand_path(dir)
  end
#+END_SRC
* Miscellaneous
** ~.gitignore~
#+BEGIN_SRC fundamental :tangle ./.gitignore
  sprout-wrap/
  cookbooks/

  .rake_test_cache

  ###
  # Ignore Chef key files and secrets
  ###
  .chef/*.pem
  .chef/encrypted_data_bag_secret

  cookbooks
  tmp
  chef-client-running.pid
#+END_SRC
* More Resources
http://gettingstartedwithchef.com/first-steps-with-chef.html
http://docs.opscode.com/install_omnibus.html
http://www.getchef.com/chef/install/


